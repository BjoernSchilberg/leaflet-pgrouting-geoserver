# Finding the shortest path in a road network with pgRouting + GeoServer + Leaflet JS

- [Finding the shortest path in a road network with pgRouting + GeoServer + Leaflet JS](#finding-the-shortest-path-in-a-road-network-with-pgrouting--geoserver--leaflet-js)
  - [Requirements as used in this example](#requirements-as-used-in-this-example)
  - [Step 0: Acquire network data](#step-0-acquire-network-data)
  - [Step 1: Create database with the required extensions](#step-1-create-database-with-the-required-extensions)
  - [Step 2: Load network data to db using ogr2ogr/osm2psql/shapeloader/etc](#step-2-load-network-data-to-db-using-ogr2ogrosm2psqlshapeloaderetc)
  - [Step 3: Add source and target  columns](#step-3-add-source-and-target-columns)
  - [Step 4: Split nodes to be used in creating topology](#step-4-split-nodes-to-be-used-in-creating-topology)
  - [Step 5: Create topology](#step-5-create-topology)
  - [Step 6: Copy  attribute information from the original table to the new noded table](#step-6-copy-attribute-information-from-the-original-table-to-the-new-noded-table)
  - [Step 7: Determine Cost](#step-7-determine-cost)
  - [Step 8: Test shortest path with Dijkistra algorithm](#step-8-test-shortest-path-with-dijkistra-algorithm)
  - [Step 9: Publishing to GeoServer](#step-9-publishing-to-geoserver)
    - [Step 9.1: **Nearest Vertex SQL View**](#step-91-nearest-vertex-sql-view)
    - [Step 9.2: **Shortest Path SQL View**](#step-92-shortest-path-sql-view)
  - [Step 10: Test GeoServer](#step-10-test-geoserver)
  - [Step 11: Leaflet JS Client](#step-11-leaflet-js-client)

This repository contains the accompaning code and writeup for this [Youtube
tutorial
series](https://www.youtube.com/watch?v=6gfdQmFkVmE&list=PLaOYwKHOUv7Z2KyZNTXhLhwYm-XeEs34H)
I did on creating a routing web app with pgRouting together with GeoServer
and Leaflet JS.

## Requirements as used in this example

- Network data
- [PostgreSQL](https://www.postgresql.org)
- [PostGIS](https://postgis.net/)
- [pgRouting](https://pgrouting.org/)
- [GeoServer](http://geoserver.org)
- [Leaflet](https://leafletjs.com)
- OS used in this example - [OSGEO Live - Lubuntu](https://live.osgeo.org/en/index.html)

## Step 0: Acquire network data

We using network data from OSM via <https://overpass-turbo.eu/> for a
section of Nairobi.

Here is a corresponding Overpass QL snippet.

```c
/*
This has been generated by the overpass-turbo wizard.
The original search was:
“highway=* ”
*/
[out:json][timeout:25];
// gather results
(
  // query part for: “highway=*”
    way["highway"]({{bbox}});
    relation["highway"]({{bbox}});
      );
      // print results
      out body;
      >;
      out skel qt;
```

## Step 1: Create database with the required extensions

Create database - here named as `routing`. Replace `<user>` with your
database user.

```sql
createdb routing -U <user>
```

Add PostGIS extension:

```shell
psql -U <user> -c "CREATE EXTENSION postgis;"  routing
```

Add pgRouting extension:

```shell
psql -U <user> -c "CREATE EXTENSION pgrouting;"  routing
```

## Step 2: Load network data to db using ogr2ogr/osm2psql/shapeloader/etc

Here we are using `ogr2ogr` to load [data/roads.geojson](data/roads.geojson).

Again do not forget to replace `<user>` with your database user.

```shell
ogr2ogr -select 'name,highway,oneway,surface' -lco GEOMETRY_NAME=the_geom -lco FID=id -f PostgreSQL PG:"dbname=routing user=<user>" -nln edges data/roads.geojson
```

A few things note on the above `ogr2ogr` command:

- `-select ‘name,highway,oneway,surface’`:  Select the desired attributes/fields only from the data file. Other attributes in the data will not be imported
- `-f PostgreSQL PG:”dbname=routing user=<user>`:  Load the data into Postgres with `<user>` and db `routing`
- `-lco GEOMETRY_NAME=the_geom`:  Store the geometry in a field named the_geom
- `-nlco FID=id`:  Store the feature identifier in a field named id
- `-nln edges`:  Store the data in a table called edges

For more details on the possible options, please refer the [
ogr2ogr documentation](https://www.gdal.org/ogr2ogr.html).

## Step 3: Add source and target  columns

To accommodate `pgr_createTopology`, we need to add source and target columns
to our edges table and then execute the command. Note that we have to
indicate the name of the table `edges` and the tolerance for considering
two vertices as the same in the network.

**First fire up the `psql` client with the correct `user` and `database`:**

```shell
psql -U <user> -d routing
```

**And then create the columns by typing the following:**

```sql
ALTER TABLE edges ADD source INT4;
ALTER TABLE edges ADD target INT4;
```

## Step 4: Split nodes to be used in creating topology

```sql
SELECT pgr_nodeNetwork('edges', 0.00001);
```

**NOTE**
We are using a tolerance of 0.00001 because our data is in EPSG:4326 (meter
as projection unit - points have to be less than 0.00001 meters away from
each other)

**Reference**:
<https://gis.stackexchange.com/questions/229452/pgr-createtopology-how-tolerance>

For details on `pgr_nodeNetwork` function please refer from
[here](https://docs.pgrouting.org/2.5/en/pgr_nodeNetwork.html#pgr-node-network)

## Step 5: Create topology

```sql
SELECT pgr_createTopology('edges_noded', 0.00001);
```

Details on `pgr_createTopology` function [here](https://docs.pgrouting.org/2.5/en/pgr_createTopology.html#pgr-create-topology)

## Step 6: Copy  attribute information from the original table to the new noded table

 **Add Columns first:**

```sql
ALTER TABLE edges_noded
 ADD COLUMN name VARCHAR,
 ADD COLUMN type VARCHAR;
 ```

**Copy the data from the original table:**

```sql
UPDATE edges_noded AS new
 SET name=old.name,
   type=old.highway
FROM edges as old
WHERE new.old_id=old.id;
```

## Step 7: Determine Cost

We will simply use distance as the costing factor. Note you can also use
other parameters like type of road, traffic, slope, etc..

**Precalculate distance to save geoserver from calculating on each request:**

**Add Distance Column:**

```sql
ALTER TABLE edges_noded ADD distance FLOAT8;
```

**Calculate distances in meters:**

```sql
UPDATE edges_noded SET distance = ST_Length(ST_Transform(the_geom, 4326)::geography) / 1000;
```

## Step 8: Test shortest path with Dijkistra algorithm

```sql
SELECT * FROM pgr_dijkstra('SELECT id,source,target,distance as cost FROM edges_noded',1,2,false);
```

For details on `pgr_dijkstra` please [check
here](https://docs.pgrouting.org/2.5/en/pgr_dijkstra.html#pgr-dijkstra).

**Eventually clean  `edges_noded` where `source` is null:**

```sql
DELETE FROM edges_noded WHERE source IS NULL;
```

## Step 9: Publishing to GeoServer

Create  2 parameterized SQL Views to have the following code:

### Step 9.1: **Nearest Vertex SQL View**

```sql
SELECT
  v.id,
  v.the_geom,
  string_agg(distinct(e.name),',') AS name
FROM
  edges_noded_vertices_pgr AS v,
  edges_noded AS e
WHERE
  v.id = (SELECT
            id
          FROM edges_noded_vertices_pgr
          ORDER BY the_geom <-> ST_SetSRID(ST_MakePoint(%x%, %y%), 4326) LIMIT 1)
  AND (e.source = v.id OR e.target = v.id)
GROUP BY v.id, v.the_geom
```

**Validation for parameters:**

To ensure that the sql view gets the correct parameters, add the below
validation that checks the values as float type in the GeoServer sql view
under the parameters:

```regex
^[\d\.\+-eE]+$
```

### Step 9.2: **Shortest Path SQL View**

```sql
SELECT
 min(r.seq) AS seq,
 e.old_id AS id,
 e.name,
 e.type,
 sum(e.distance) AS distance,
ST_Collect(e.the_geom) AS geom
 FROM pgr_dijkstra('SELECT id,source,target,distance AS cost
 FROM edges_noded',%source%,%target%,false) AS r,edges_noded AS e
 WHERE r.edge=e.id GROUP BY e.old_id,e.name,e.type
```

**Validation for parameters:**

Ensure parameters are integers:

```regex
^[\d]+$
```

## Step 10: Test GeoServer

**Test nearest_vertex:**

<http://localhost:8181/geoserver/wfs?service=WFS&version=1.0.0&request=GetFeature&typeName=routing:nearest_vertex&outputformat=application/json&viewparams=x:36.2825;y:-1.2829>

```json
{
    "crs": {
        "properties": {
            "name": "urn:ogc:def:crs:EPSG::4326"
        },
        "type": "name"
    },
    "features": [
        {
            "geometry": {
                "coordinates": [
                    36.8021031,
                    -1.2649685
                ],
                "type": "Point"
            },
            "geometry_name": "the_geom",
            "id": "nearest_vertex.fid-5697da35_16f9004b10a_-7ff5",
            "properties": {
                "id": 203,
                "name": "Waiyaki Way"
            },
            "type": "Feature"
        }
    ],
    "numberMatched": 1,
    "numberReturned": 1,
    "timeStamp": "2020-01-10T15:38:34.369Z",
    "totalFeatures": 1,
    "type": "FeatureCollection"
}
```

**Simple test shortest path:**

<http://localhost:8181/geoserver/wfs?service=WFS&version=1.0.0&request=GetFeature&typeName=routing:shortest_path&outputformat=application/json&viewparams=source:1;target:2>

```json
    {
    "crs": {
        "properties": {
            "name": "urn:ogc:def:crs:EPSG::4326"
        },
        "type": "name"
    },
    "features": [
        {
            "geometry": {
                "coordinates": [
                    [
                        [
                            36.8135802,
                            -1.2872126
                        ],
                        [
                            36.81396484,
                            -1.28738089
                        ]
                    ]
                ],
                "type": "MultiLineString"
            },
            "geometry_name": "geom",
            "id": "shortest_path.fid-5697da35_16f9004b10a_-7fd0",
            "properties": {
                "distance": 0.04667712950829339,
                "id": 1,
                "name": "Processional Way",
                "seq": 1,
                "type": "tertiary"
            },
            "type": "Feature"
        }
    ],
    "numberMatched": 1,
    "numberReturned": 1,
    "timeStamp": "2020-01-10T16:47:42.234Z",
    "totalFeatures": 1,
    "type": "FeatureCollection"
}
```

**Advanced test shortest path:**

<http://localhost:8181/geoserver/wfs?service=WFS&version=1.0.0&request=GetFeature&typeName=routing:shortest_path&outputformat=application/json&viewparams=source:1;target:1151>

Hint: Test results in <http://geojson.io>.

## Step 11: Leaflet JS Client

Please take a look at the code and it should be easy to follow along with the comments in the code [web/js/app.js](web/js/app.js).
